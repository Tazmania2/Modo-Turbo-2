import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import * as path from 'path';
import { SecurityVulnerability, DependencyAuditResult, SecurityImpactAnalysis } from '../../types/analysis.types';

const execAsync = promisify(exec);

export interface VulnerabilityDatabase {
  advisories: VulnerabilityAdvisory[];
  lastUpdated: Date;
}

export interface VulnerabilityAdvisory {
  id: string;
  package: string;
  versions: string[];
  severity: 'low' | 'moderate' | 'high' | 'critical';
  title: string;
  description: string;
  cwe: string[];
  cvss: number;
  patchedVersions: string;
  recommendation: string;
  references: string[];
}

export interface DependencyVulnerabilityResult {
  package: string;
  version: string;
  vulnerabilities: SecurityVulnerability[];
  auditResult: DependencyAuditResult;
  riskScore: number;
  recommendation: 'update' | 'replace' | 'remove' | 'monitor';
}

export interface VulnerabilityScanOptions {
  includeDevDependencies: boolean;
  severityThreshold: 'low' | 'moderate' | 'high' | 'critical';
  excludePackages: string[];
  customDatabase?: string;
}

export class DependencyVulnerabilityScanner {
  private vulnerabilityDatabase: VulnerabilityDatabase | null = null;
  private readonly defaultOptions: VulnerabilityScanOptions = {
    includeDevDependencies: false,
    severityThreshold: 'moderate',
    excludePackages: []
  };

  /**
   * Scan dependencies for vulnerabilities using npm audit and custom database
   */
  async scanDependencies(
    projectPath: string,
    options: Partial<VulnerabilityScanOptions> = {}
  ): Promise<DependencyVulnerabilityResult[]> {
    const scanOptions = { ...this.defaultOptions, ...options };
    
    try {
      // Load vulnerability database
      await this.loadVulnerabilityDatabase(scanOptions.customDatabase);
      
      // Get package.json dependencies
      const dependencies = await this.getDependencies(projectPath, scanOptions.includeDevDependencies);
      
      // Run npm audit
      const npmAuditResults = await this.runNpmAudit(projectPath);
      
      // Scan each dependency
      const results: DependencyVulnerabilityResult[] = [];
      
      for (const [packageName, version] of Object.entries(dependencies)) {
        if (scanOptions.excludePackages.includes(packageName)) {
          continue;
        }
        
        const vulnerabilities = await this.scanPackage(packageName, version);
        const filteredVulnerabilities = this.filterBySeverity(vulnerabilities, scanOptions.severityThreshold);
        
        if (filteredVulnerabilities.length > 0) {
          const auditResult = this.getAuditResult(packageName, npmAuditResults);
          const riskScore = this.calculateRiskScore(filteredVulnerabilities);
          const recommendation = this.getRecommendation(filteredVulnerabilities, riskScore);
          
          results.push({
            package: packageName,
            version,
            vulnerabilities: filteredVulnerabilities,
            auditResult,
            riskScore,
            recommendation
          });
        }
      }
      
      return results.sort((a, b) => b.riskScore - a.riskScore);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`Dependency vulnerability scan failed: ${errorMessage}`);
    }
  }

  /**
   * Get security impact analysis comparing two dependency sets
   */
  async compareSecurityImpact(
    oldDependencies: Record<string, string>,
    newDependencies: Record<string, string>
  ): Promise<SecurityImpactAnalysis> {
    const oldVulns = await this.scanDependencySet(oldDependencies);
    const newVulns = await this.scanDependencySet(newDependencies);
    
    const oldVulnCount = oldVulns.reduce((sum, dep) => sum + dep.vulnerabilities.length, 0);
    const newVulnCount = newVulns.reduce((sum, dep) => sum + dep.vulnerabilities.length, 0);
    
    const criticalIssues = newVulns
      .flatMap(dep => dep.vulnerabilities)
      .filter(vuln => vuln.severity === 'critical');
    
    return {
      newVulnerabilities: Math.max(0, newVulnCount - oldVulnCount),
      resolvedVulnerabilities: Math.max(0, oldVulnCount - newVulnCount),
      riskChange: newVulnCount > oldVulnCount ? 'increased' : 
                  newVulnCount < oldVulnCount ? 'decreased' : 'unchanged',
      criticalIssues
    };
  }

  /**
   * Generate vulnerability report
   */
  generateVulnerabilityReport(results: DependencyVulnerabilityResult[]): {
    summary: {
      totalPackages: number;
      vulnerablePackages: number;
      totalVulnerabilities: number;
      criticalVulnerabilities: number;
      highVulnerabilities: number;
      averageRiskScore: number;
    };
    recommendations: string[];
    priorityActions: string[];
  } {
    const totalVulns = results.reduce((sum, dep) => sum + dep.vulnerabilities.length, 0);
    const criticalVulns = results.reduce((sum, dep) => 
      sum + dep.vulnerabilities.filter(v => v.severity === 'critical').length, 0);
    const highVulns = results.reduce((sum, dep) => 
      sum + dep.vulnerabilities.filter(v => v.severity === 'high').length, 0);
    
    const avgRiskScore = results.length > 0 ? 
      results.reduce((sum, dep) => sum + dep.riskScore, 0) / results.length : 0;
    
    const recommendations = this.generateRecommendations(results);
    const priorityActions = this.generatePriorityActions(results);
    
    return {
      summary: {
        totalPackages: results.length,
        vulnerablePackages: results.length,
        totalVulnerabilities: totalVulns,
        criticalVulnerabilities: criticalVulns,
        highVulnerabilities: highVulns,
        averageRiskScore: Math.round(avgRiskScore * 100) / 100
      },
      recommendations,
      priorityActions
    };
  }

  private async loadVulnerabilityDatabase(customPath?: string): Promise<void> {
    try {
      const dbPath = customPath || path.join(__dirname, '../../../data/vulnerability-db.json');
      
      try {
        const dbContent = await fs.readFile(dbPath, 'utf-8');
        this.vulnerabilityDatabase = JSON.parse(dbContent);
      } catch (error) {
        // Use built-in database if custom one fails
        this.vulnerabilityDatabase = {
          advisories: [],
          lastUpdated: new Date()
        };
      }
    } catch (error) {
      console.warn('Failed to load vulnerability database, using empty database');
      this.vulnerabilityDatabase = {
        advisories: [],
        lastUpdated: new Date()
      };
    }
  }

  private async getDependencies(
    projectPath: string, 
    includeDevDependencies: boolean
  ): Promise<Record<string, string>> {
    const packageJsonPath = path.join(projectPath, 'package.json');
    
    try {
      const packageJsonContent = await fs.readFile(packageJsonPath, 'utf-8');
      const packageJson = JSON.parse(packageJsonContent);
      
      const dependencies = { ...packageJson.dependencies || {} };
      
      if (includeDevDependencies) {
        Object.assign(dependencies, packageJson.devDependencies || {});
      }
      
      return dependencies;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`Failed to read package.json: ${errorMessage}`);
    }
  }

  private async runNpmAudit(projectPath: string): Promise<any> {
    try {
      const { stdout } = await execAsync('npm audit --json', { 
        cwd: projectPath,
        timeout: 30000 
      });
      return JSON.parse(stdout);
    } catch (error: any) {
      // npm audit returns non-zero exit code when vulnerabilities are found
      if (error.stdout) {
        try {
          return JSON.parse(error.stdout);
        } catch (parseError) {
          console.warn('Failed to parse npm audit output');
          return { vulnerabilities: {} };
        }
      }
      return { vulnerabilities: {} };
    }
  }

  private async scanPackage(packageName: string, version: string): Promise<SecurityVulnerability[]> {
    if (!this.vulnerabilityDatabase) {
      return [];
    }
    
    const vulnerabilities: SecurityVulnerability[] = [];
    
    for (const advisory of this.vulnerabilityDatabase.advisories) {
      if (advisory.package === packageName && this.isVersionVulnerable(version, advisory.versions)) {
        vulnerabilities.push({
          id: advisory.id,
          severity: advisory.severity,
          title: advisory.title,
          description: advisory.description,
          package: packageName,
          version,
          patchedVersions: advisory.patchedVersions,
          recommendation: advisory.recommendation
        });
      }
    }
    
    return vulnerabilities;
  }

  private async scanDependencySet(dependencies: Record<string, string>): Promise<DependencyVulnerabilityResult[]> {
    const results: DependencyVulnerabilityResult[] = [];
    
    for (const [packageName, version] of Object.entries(dependencies)) {
      const vulnerabilities = await this.scanPackage(packageName, version);
      
      if (vulnerabilities.length > 0) {
        const riskScore = this.calculateRiskScore(vulnerabilities);
        const recommendation = this.getRecommendation(vulnerabilities, riskScore);
        
        results.push({
          package: packageName,
          version,
          vulnerabilities,
          auditResult: {
            package: packageName,
            version,
            vulnerabilities: vulnerabilities.length,
            severity: this.getHighestSeverity(vulnerabilities),
            recommendation
          },
          riskScore,
          recommendation
        });
      }
    }
    
    return results;
  }

  private isVersionVulnerable(version: string, vulnerableVersions: string[]): boolean {
    // Simple version matching - in production, use semver library
    return vulnerableVersions.some(vulnVersion => {
      if (vulnVersion.includes('*')) {
        const pattern = vulnVersion.replace(/\*/g, '.*');
        return new RegExp(pattern).test(version);
      }
      return version === vulnVersion;
    });
  }

  private filterBySeverity(
    vulnerabilities: SecurityVulnerability[], 
    threshold: 'low' | 'moderate' | 'high' | 'critical'
  ): SecurityVulnerability[] {
    const severityOrder = ['low', 'moderate', 'high', 'critical'];
    const thresholdIndex = severityOrder.indexOf(threshold);
    
    return vulnerabilities.filter(vuln => {
      const vulnIndex = severityOrder.indexOf(vuln.severity);
      return vulnIndex >= thresholdIndex;
    });
  }

  private getAuditResult(packageName: string, npmAuditResults: any): DependencyAuditResult {
    const vulnerabilities = npmAuditResults.vulnerabilities || {};
    const packageVulns = vulnerabilities[packageName] || {};
    
    return {
      package: packageName,
      version: packageVulns.version || 'unknown',
      vulnerabilities: packageVulns.via?.length || 0,
      severity: packageVulns.severity || 'low',
      recommendation: this.getRecommendationFromSeverity(packageVulns.severity || 'low')
    };
  }

  private calculateRiskScore(vulnerabilities: SecurityVulnerability[]): number {
    const severityWeights = {
      low: 1,
      moderate: 3,
      high: 7,
      critical: 10
    };
    
    return vulnerabilities.reduce((score, vuln) => {
      return score + severityWeights[vuln.severity];
    }, 0);
  }

  private getRecommendation(
    vulnerabilities: SecurityVulnerability[], 
    riskScore: number
  ): 'update' | 'replace' | 'remove' | 'monitor' {
    const hasCritical = vulnerabilities.some(v => v.severity === 'critical');
    const hasHigh = vulnerabilities.some(v => v.severity === 'high');
    
    if (hasCritical || riskScore > 20) {
      return 'replace';
    } else if (hasHigh || riskScore > 10) {
      return 'update';
    } else if (riskScore > 5) {
      return 'monitor';
    } else {
      return 'update';
    }
  }

  private getRecommendationFromSeverity(severity: string): 'update' | 'replace' | 'remove' | 'monitor' {
    switch (severity) {
      case 'critical':
        return 'replace';
      case 'high':
        return 'update';
      case 'moderate':
        return 'update';
      default:
        return 'monitor';
    }
  }

  private getHighestSeverity(vulnerabilities: SecurityVulnerability[]): 'low' | 'moderate' | 'high' | 'critical' {
    const severityOrder = ['low', 'moderate', 'high', 'critical'];
    
    return vulnerabilities.reduce((highest, vuln) => {
      const currentIndex = severityOrder.indexOf(vuln.severity);
      const highestIndex = severityOrder.indexOf(highest);
      return currentIndex > highestIndex ? vuln.severity : highest;
    }, 'low' as 'low' | 'moderate' | 'high' | 'critical');
  }

  private generateRecommendations(results: DependencyVulnerabilityResult[]): string[] {
    const recommendations: string[] = [];
    
    const criticalPackages = results.filter(r => r.recommendation === 'replace');
    const updatePackages = results.filter(r => r.recommendation === 'update');
    const monitorPackages = results.filter(r => r.recommendation === 'monitor');
    
    if (criticalPackages.length > 0) {
      recommendations.push(
        `Immediately replace ${criticalPackages.length} critical packages: ${criticalPackages.map(p => p.package).join(', ')}`
      );
    }
    
    if (updatePackages.length > 0) {
      recommendations.push(
        `Update ${updatePackages.length} packages with security patches: ${updatePackages.map(p => p.package).join(', ')}`
      );
    }
    
    if (monitorPackages.length > 0) {
      recommendations.push(
        `Monitor ${monitorPackages.length} packages for future updates: ${monitorPackages.map(p => p.package).join(', ')}`
      );
    }
    
    return recommendations;
  }

  private generatePriorityActions(results: DependencyVulnerabilityResult[]): string[] {
    const actions: string[] = [];
    
    // Sort by risk score descending
    const sortedResults = results.sort((a, b) => b.riskScore - a.riskScore);
    
    // Top 5 priority actions
    for (const result of sortedResults.slice(0, 5)) {
      const criticalVulns = result.vulnerabilities.filter(v => v.severity === 'critical').length;
      const highVulns = result.vulnerabilities.filter(v => v.severity === 'high').length;
      
      let action = `${result.package}@${result.version}: `;
      
      if (criticalVulns > 0) {
        action += `${criticalVulns} critical vulnerabilities - IMMEDIATE ACTION REQUIRED`;
      } else if (highVulns > 0) {
        action += `${highVulns} high severity vulnerabilities - Update within 24 hours`;
      } else {
        action += `${result.vulnerabilities.length} vulnerabilities - Schedule update`;
      }
      
      actions.push(action);
    }
    
    return actions;
  }
}

export const dependencyVulnerabilityScanner = new DependencyVulnerabilityScanner();