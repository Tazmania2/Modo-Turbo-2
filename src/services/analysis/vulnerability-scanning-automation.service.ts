import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import * as path from 'path';
import { 
  SecurityVulnerability, 
  DependencyAuditResult,
  SecurityIssue 
} from '@/types/analysis.types';
import { dependencyVulnerabilityScanner } from './dependency-vulnerability-scanner.service';

const execAsync = promisify(exec);

export interface VulnerabilityScanSchedule {
  id: string;
  name: string;
  description: string;
  frequency: 'hourly' | 'daily' | 'weekly' | 'monthly';
  enabled: boolean;
  scanTypes: VulnerabilityScanType[];
  notificationSettings: NotificationSettings;
  lastRun?: Date;
  nextRun?: Date;
}

export interface VulnerabilityScanType {
  type: 'dependencies' | 'code' | 'configuration' | 'infrastructure' | 'secrets';
  enabled: boolean;
  config: any;
}

export interface NotificationSettings {
  email: boolean;
  slack: boolean;
  webhook?: string;
  severityThreshold: 'low' | 'medium' | 'high' | 'critical';
  recipients: string[];
}

export interface AutomatedScanResult {
  scanId: string;
  timestamp: Date;
  scanType: string;
  status: 'completed' | 'failed' | 'in-progress';
  vulnerabilities: SecurityVulnerability[];
  issues: SecurityIssue[];
  summary: {
    totalVulnerabilities: number;
    criticalCount: number;
    highCount: number;
    mediumCount: number;
    lowCount: number;
  };
  executionTime: number;
  recommendations: string[];
}

export interface ScanConfiguration {
  projectPath: string;
  excludePatterns: string[];
  includePatterns: string[];
  severityThreshold: 'low' | 'medium' | 'high' | 'critical';
  maxExecutionTime: number;
  retryAttempts: number;
  customRules: SecurityScanRule[];
}

export interface SecurityScanRule {
  id: string;
  name: string;
  description: string;
  pattern: string | RegExp;
  severity: 'low' | 'medium' | 'high' | 'critical';
  category: string;
  enabled: boolean;
  remediation: string;
}

export interface ContinuousMonitoringConfig {
  enabled: boolean;
  scanInterval: number; // minutes
  alertThresholds: {
    newVulnerabilities: number;
    criticalVulnerabilities: number;
    securityScoreDecrease: number;
  };
  integrations: {
    github: boolean;
    slack: boolean;
    email: boolean;
    webhook?: string;
  };
}

export class VulnerabilityScanningAutomationService {
  private scanSchedules: Map<string, VulnerabilityScanSchedule> = new Map();
  private activeScanners: Map<string, NodeJS.Timeout> = new Map();
  private scanHistory: AutomatedScanResult[] = [];
  private continuousMonitoring: ContinuousMonitoringConfig | null = null;

  constructor() {
    this.initializeDefaultSchedules();
  }

  /**
   * Schedules automated vulnerability scans
   */
  async scheduleVulnerabilityScans(schedule: VulnerabilityScanSchedule): Promise<void> {
    this.scanSchedules.set(schedule.id, schedule);
    
    if (schedule.enabled) {
      await this.startScheduledScan(schedule);
    }
  }

  /**
   * Runs immediate vulnerability scan
   */
  async runImmediateScan(
    scanTypes: VulnerabilityScanType[],
    config: ScanConfiguration
  ): Promise<AutomatedScanResult> {
    const scanId = `immediate-${Date.now()}`;
    const startTime = Date.now();

    try {
      const vulnerabilities: SecurityVulnerability[] = [];
      const issues: SecurityIssue[] = [];
      const recommendations: string[] = [];

      for (const scanType of scanTypes) {
        if (!scanType.enabled) continue;

        switch (scanType.type) {
          case 'dependencies':
            const depResults = await this.scanDependencies(config);
            vulnerabilities.push(...depResults.vulnerabilities);
            recommendations.push(...depResults.recommendations);
            break;

          case 'code':
            const codeResults = await this.scanCode(config);
            issues.push(...codeResults.issues);
            recommendations.push(...codeResults.recommendations);
            break;

          case 'configuration':
            const configResults = await this.scanConfiguration(config);
            issues.push(...configResults.issues);
            recommendations.push(...configResults.recommendations);
            break;

          case 'secrets':
            const secretResults = await this.scanSecrets(config);
            issues.push(...secretResults.issues);
            recommendations.push(...secretResults.recommendations);
            break;

          case 'infrastructure':
            const infraResults = await this.scanInfrastructure(config);
            issues.push(...infraResults.issues);
            recommendations.push(...infraResults.recommendations);
            break;
        }
      }

      const summary = this.generateScanSummary(vulnerabilities, issues);
      const executionTime = Date.now() - startTime;

      const result: AutomatedScanResult = {
        scanId,
        timestamp: new Date(),
        scanType: scanTypes.map(t => t.type).join(', '),
        status: 'completed',
        vulnerabilities,
        issues,
        summary,
        executionTime,
        recommendations: [...new Set(recommendations)]
      };

      this.scanHistory.push(result);
      await this.processScanResult(result);

      return result;
    } catch (error) {
      const result: AutomatedScanResult = {
        scanId,
        timestamp: new Date(),
        scanType: scanTypes.map(t => t.type).join(', '),
        status: 'failed',
        vulnerabilities: [],
        issues: [{
          type: 'scan-error',
          severity: 'high',
          file: 'scanner',
          line: 0,
          description: `Scan failed: ${error instanceof Error ? error.message : String(error)}`,
          recommendation: 'Check scan configuration and retry'
        }],
        summary: { totalVulnerabilities: 0, criticalCount: 0, highCount: 0, mediumCount: 0, lowCount: 0 },
        executionTime: Date.now() - startTime,
        recommendations: ['Fix scan configuration and retry']
      };

      this.scanHistory.push(result);
      throw error;
    }
  }

  /**
   * Enables continuous security monitoring
   */
  async enableContinuousMonitoring(config: ContinuousMonitoringConfig): Promise<void> {
    this.continuousMonitoring = config;

    if (config.enabled) {
      const monitoringInterval = setInterval(async () => {
        await this.runContinuousMonitoringScan();
      }, config.scanInterval * 60 * 1000); // Convert minutes to milliseconds

      this.activeScanners.set('continuous-monitoring', monitoringInterval);
    }
  }

  /**
   * Disables continuous security monitoring
   */
  disableContinuousMonitoring(): void {
    const monitoringTimer = this.activeScanners.get('continuous-monitoring');
    if (monitoringTimer) {
      clearInterval(monitoringTimer);
      this.activeScanners.delete('continuous-monitoring');
    }
    
    if (this.continuousMonitoring) {
      this.continuousMonitoring.enabled = false;
    }
  }

  /**
   * Gets scan history and analytics
   */
  getScanHistory(limit?: number): AutomatedScanResult[] {
    const sortedHistory = this.scanHistory.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    return limit ? sortedHistory.slice(0, limit) : sortedHistory;
  }

  /**
   * Gets vulnerability trends over time
   */
  getVulnerabilityTrends(days: number = 30): {
    date: string;
    totalVulnerabilities: number;
    criticalCount: number;
    highCount: number;
    mediumCount: number;
    lowCount: number;
  }[] {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);

    const relevantScans = this.scanHistory.filter(scan => scan.timestamp >= cutoffDate);
    
    // Group by date
    const trendMap = new Map<string, {
      totalVulnerabilities: number;
      criticalCount: number;
      highCount: number;
      mediumCount: number;
      lowCount: number;
    }>();

    relevantScans.forEach(scan => {
      const dateKey = scan.timestamp.toISOString().split('T')[0];
      const existing = trendMap.get(dateKey) || {
        totalVulnerabilities: 0,
        criticalCount: 0,
        highCount: 0,
        mediumCount: 0,
        lowCount: 0
      };

      existing.totalVulnerabilities += scan.summary.totalVulnerabilities;
      existing.criticalCount += scan.summary.criticalCount;
      existing.highCount += scan.summary.highCount;
      existing.mediumCount += scan.summary.mediumCount;
      existing.lowCount += scan.summary.lowCount;

      trendMap.set(dateKey, existing);
    });

    return Array.from(trendMap.entries()).map(([date, data]) => ({
      date,
      ...data
    })).sort((a, b) => a.date.localeCompare(b.date));
  }

  /**
   * Generates security dashboard metrics
   */
  getSecurityDashboardMetrics(): {
    currentSecurityScore: number;
    totalVulnerabilities: number;
    criticalVulnerabilities: number;
    trendsLast30Days: any[];
    topVulnerabilityTypes: { type: string; count: number }[];
    scanFrequency: { successful: number; failed: number; total: number };
    lastScanDate: Date | null;
    nextScheduledScan: Date | null;
  } {
    const recentScans = this.getScanHistory(10);
    const last30DaysTrends = this.getVulnerabilityTrends(30);
    
    const latestScan = recentScans[0];
    const currentSecurityScore = this.calculateSecurityScore(latestScan);
    
    const totalVulnerabilities = latestScan?.summary.totalVulnerabilities || 0;
    const criticalVulnerabilities = latestScan?.summary.criticalCount || 0;

    // Calculate vulnerability types
    const vulnerabilityTypes = new Map<string, number>();
    recentScans.forEach(scan => {
      scan.vulnerabilities.forEach(vuln => {
        const type = vuln.package ? 'dependency' : 'code';
        vulnerabilityTypes.set(type, (vulnerabilityTypes.get(type) || 0) + 1);
      });
      scan.issues.forEach(issue => {
        vulnerabilityTypes.set(issue.type, (vulnerabilityTypes.get(issue.type) || 0) + 1);
      });
    });

    const topVulnerabilityTypes = Array.from(vulnerabilityTypes.entries())
      .map(([type, count]) => ({ type, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    // Calculate scan frequency
    const successful = recentScans.filter(s => s.status === 'completed').length;
    const failed = recentScans.filter(s => s.status === 'failed').length;
    const total = recentScans.length;

    const lastScanDate = latestScan?.timestamp || null;
    const nextScheduledScan = this.getNextScheduledScanDate();

    return {
      currentSecurityScore,
      totalVulnerabilities,
      criticalVulnerabilities,
      trendsLast30Days: last30DaysTrends,
      topVulnerabilityTypes,
      scanFrequency: { successful, failed, total },
      lastScanDate,
      nextScheduledScan
    };
  }

  // Private methods
  private async startScheduledScan(schedule: VulnerabilityScanSchedule): Promise<void> {
    const intervalMs = this.getIntervalMs(schedule.frequency);
    
    const timer = setInterval(async () => {
      try {
        const config: ScanConfiguration = {
          projectPath: process.cwd(),
          excludePatterns: ['node_modules/**', '**/*.test.ts'],
          includePatterns: ['**/*.ts', '**/*.js', '**/*.json'],
          severityThreshold: 'medium',
          maxExecutionTime: 300000, // 5 minutes
          retryAttempts: 3,
          customRules: []
        };

        await this.runImmediateScan(schedule.scanTypes, config);
        
        // Update schedule
        schedule.lastRun = new Date();
        schedule.nextRun = new Date(Date.now() + intervalMs);
        this.scanSchedules.set(schedule.id, schedule);
      } catch (error) {
        console.error(`Scheduled scan ${schedule.id} failed:`, error);
      }
    }, intervalMs);

    this.activeScanners.set(schedule.id, timer);
  }

  private getIntervalMs(frequency: string): number {
    switch (frequency) {
      case 'hourly': return 60 * 60 * 1000;
      case 'daily': return 24 * 60 * 60 * 1000;
      case 'weekly': return 7 * 24 * 60 * 60 * 1000;
      case 'monthly': return 30 * 24 * 60 * 60 * 1000;
      default: return 24 * 60 * 60 * 1000; // Default to daily
    }
  }

  private async scanDependencies(config: ScanConfiguration): Promise<{
    vulnerabilities: SecurityVulnerability[];
    recommendations: string[];
  }> {
    try {
      const results = await dependencyVulnerabilityScanner.scanDependencies(
        config.projectPath,
        {
          includeDevDependencies: false,
          severityThreshold: config.severityThreshold === 'medium' ? 'moderate' : config.severityThreshold as 'low' | 'moderate' | 'high' | 'critical',
          excludePackages: []
        }
      );

      const vulnerabilities = results.flatMap(r => r.vulnerabilities);
      const recommendations = results.flatMap(r => [r.auditResult.recommendation]);

      return { vulnerabilities, recommendations };
    } catch (error) {
      console.error('Dependency scan failed:', error);
      return { vulnerabilities: [], recommendations: ['Fix dependency scanner configuration'] };
    }
  }

  private async scanCode(config: ScanConfiguration): Promise<{
    issues: SecurityIssue[];
    recommendations: string[];
  }> {
    const issues: SecurityIssue[] = [];
    const recommendations: string[] = [];

    try {
      // Run ESLint security rules
      const eslintResults = await this.runESLintSecurity(config.projectPath);
      issues.push(...eslintResults.issues);
      recommendations.push(...eslintResults.recommendations);

      // Run custom security rules
      const customResults = await this.runCustomSecurityRules(config);
      issues.push(...customResults.issues);
      recommendations.push(...customResults.recommendations);

    } catch (error) {
      console.error('Code scan failed:', error);
      issues.push({
        type: 'scan-error',
        severity: 'medium',
        file: 'code-scanner',
        line: 0,
        description: `Code scan failed: ${error instanceof Error ? error.message : String(error)}`,
        recommendation: 'Check code scanner configuration'
      });
    }

    return { issues, recommendations };
  }

  private async scanConfiguration(config: ScanConfiguration): Promise<{
    issues: SecurityIssue[];
    recommendations: string[];
  }> {
    const issues: SecurityIssue[] = [];
    const recommendations: string[] = [];

    try {
      // Check for insecure configurations
      const configFiles = ['package.json', 'next.config.ts', '.env.example'];
      
      for (const configFile of configFiles) {
        const filePath = path.join(config.projectPath, configFile);
        
        try {
          const content = await fs.readFile(filePath, 'utf-8');
          const configIssues = this.analyzeConfigurationFile(configFile, content);
          issues.push(...configIssues);
        } catch (error) {
          // File doesn't exist or can't be read, skip
        }
      }

      if (issues.length > 0) {
        recommendations.push('Review and fix configuration security issues');
      }

    } catch (error) {
      console.error('Configuration scan failed:', error);
    }

    return { issues, recommendations };
  }

  private async scanSecrets(config: ScanConfiguration): Promise<{
    issues: SecurityIssue[];
    recommendations: string[];
  }> {
    const issues: SecurityIssue[] = [];
    const recommendations: string[] = [];

    try {
      // Simple secret detection patterns
      const secretPatterns = [
        { pattern: /api[_-]?key\s*[:=]\s*["'][^"']+["']/gi, type: 'api-key' },
        { pattern: /password\s*[:=]\s*["'][^"']+["']/gi, type: 'password' },
        { pattern: /secret\s*[:=]\s*["'][^"']+["']/gi, type: 'secret' },
        { pattern: /token\s*[:=]\s*["'][^"']+["']/gi, type: 'token' }
      ];

      // Scan files for secrets
      const files = await this.getFilesToScan(config);
      
      for (const file of files) {
        const content = await fs.readFile(file, 'utf-8');
        
        for (const { pattern, type } of secretPatterns) {
          const matches = content.match(pattern);
          if (matches) {
            issues.push({
              type: 'hardcoded-secret',
              severity: 'critical',
              file,
              line: 0,
              description: `Potential hardcoded ${type} found`,
              recommendation: `Move ${type} to environment variables`
            });
          }
        }
      }

      if (issues.length > 0) {
        recommendations.push('Remove hardcoded secrets and use environment variables');
      }

    } catch (error) {
      console.error('Secret scan failed:', error);
    }

    return { issues, recommendations };
  }

  private async scanInfrastructure(config: ScanConfiguration): Promise<{
    issues: SecurityIssue[];
    recommendations: string[];
  }> {
    const issues: SecurityIssue[] = [];
    const recommendations: string[] = [];

    try {
      // Check Docker configuration if present
      const dockerfilePath = path.join(config.projectPath, 'Dockerfile');
      try {
        const dockerContent = await fs.readFile(dockerfilePath, 'utf-8');
        const dockerIssues = this.analyzeDockerfile(dockerContent);
        issues.push(...dockerIssues);
      } catch (error) {
        // Dockerfile doesn't exist, skip
      }

      // Check deployment configurations
      const deploymentConfigs = ['vercel.json', 'netlify.toml', 'docker-compose.yml'];
      for (const configFile of deploymentConfigs) {
        const filePath = path.join(config.projectPath, configFile);
        try {
          const content = await fs.readFile(filePath, 'utf-8');
          const deployIssues = this.analyzeDeploymentConfig(configFile, content);
          issues.push(...deployIssues);
        } catch (error) {
          // Config file doesn't exist, skip
        }
      }

      if (issues.length > 0) {
        recommendations.push('Review infrastructure security configurations');
      }

    } catch (error) {
      console.error('Infrastructure scan failed:', error);
    }

    return { issues, recommendations };
  }

  private async runESLintSecurity(projectPath: string): Promise<{
    issues: SecurityIssue[];
    recommendations: string[];
  }> {
    const issues: SecurityIssue[] = [];
    const recommendations: string[] = [];

    try {
      // Run ESLint with security plugin
      const { stdout } = await execAsync(
        'npx eslint --ext .ts,.js --format json .',
        { cwd: projectPath, timeout: 60000 }
      );

      const eslintResults = JSON.parse(stdout);
      
      eslintResults.forEach((fileResult: any) => {
        fileResult.messages.forEach((message: any) => {
          if (message.ruleId && message.ruleId.includes('security')) {
            issues.push({
              type: message.ruleId,
              severity: message.severity === 2 ? 'high' : 'medium',
              file: fileResult.filePath,
              line: message.line,
              description: message.message,
              recommendation: 'Fix ESLint security rule violation'
            });
          }
        });
      });

    } catch (error) {
      // ESLint might not be configured or might have errors
      console.warn('ESLint security scan failed:', error instanceof Error ? error.message : String(error));
    }

    return { issues, recommendations };
  }

  private async runCustomSecurityRules(config: ScanConfiguration): Promise<{
    issues: SecurityIssue[];
    recommendations: string[];
  }> {
    const issues: SecurityIssue[] = [];
    const recommendations: string[] = [];

    try {
      const files = await this.getFilesToScan(config);
      
      for (const file of files) {
        const content = await fs.readFile(file, 'utf-8');
        
        for (const rule of config.customRules) {
          if (!rule.enabled) continue;
          
          const pattern = typeof rule.pattern === 'string' ? new RegExp(rule.pattern, 'gi') : rule.pattern;
          const matches = content.match(pattern);
          
          if (matches) {
            issues.push({
              type: rule.id,
              severity: rule.severity,
              file,
              line: 0,
              description: rule.description,
              recommendation: rule.remediation
            });
          }
        }
      }

    } catch (error) {
      console.error('Custom security rules scan failed:', error);
    }

    return { issues, recommendations };
  }

  private async getFilesToScan(config: ScanConfiguration): Promise<string[]> {
    const files: string[] = [];
    
    try {
      const { stdout } = await execAsync(
        `find ${config.projectPath} -type f \\( -name "*.ts" -o -name "*.js" -o -name "*.json" \\)`,
        { timeout: 30000 }
      );
      
      files.push(...stdout.trim().split('\n').filter(f => f.length > 0));
    } catch (error) {
      console.error('Failed to get files to scan:', error);
    }

    return files;
  }

  private analyzeConfigurationFile(filename: string, content: string): SecurityIssue[] {
    const issues: SecurityIssue[] = [];

    // Check for insecure configurations
    if (filename === 'package.json') {
      try {
        const packageJson = JSON.parse(content);
        
        // Check for scripts with potential security issues
        if (packageJson.scripts) {
          Object.entries(packageJson.scripts).forEach(([scriptName, script]) => {
            if (typeof script === 'string' && script.includes('--disable-host-check')) {
              issues.push({
                type: 'insecure-dev-server',
                severity: 'medium',
                file: filename,
                line: 0,
                description: 'Development server configured with disabled host checking',
                recommendation: 'Remove --disable-host-check flag for security'
              });
            }
          });
        }
      } catch (error) {
        // Invalid JSON, skip analysis
      }
    }

    return issues;
  }

  private analyzeDockerfile(content: string): SecurityIssue[] {
    const issues: SecurityIssue[] = [];

    // Check for running as root
    if (!content.includes('USER ') || content.includes('USER root')) {
      issues.push({
        type: 'docker-root-user',
        severity: 'high',
        file: 'Dockerfile',
        line: 0,
        description: 'Container runs as root user',
        recommendation: 'Create and use a non-root user in Dockerfile'
      });
    }

    // Check for COPY with broad permissions
    if (content.includes('COPY . .')) {
      issues.push({
        type: 'docker-broad-copy',
        severity: 'medium',
        file: 'Dockerfile',
        line: 0,
        description: 'Dockerfile copies entire context',
        recommendation: 'Use specific COPY commands and .dockerignore'
      });
    }

    return issues;
  }

  private analyzeDeploymentConfig(filename: string, content: string): SecurityIssue[] {
    const issues: SecurityIssue[] = [];

    // Basic security checks for deployment configurations
    if (content.toLowerCase().includes('http://') && !content.toLowerCase().includes('localhost')) {
      issues.push({
        type: 'insecure-http',
        severity: 'medium',
        file: filename,
        line: 0,
        description: 'HTTP URLs found in deployment configuration',
        recommendation: 'Use HTTPS URLs for security'
      });
    }

    return issues;
  }

  private generateScanSummary(vulnerabilities: SecurityVulnerability[], issues: SecurityIssue[]): {
    totalVulnerabilities: number;
    criticalCount: number;
    highCount: number;
    mediumCount: number;
    lowCount: number;
  } {
    const allItems = [
      ...vulnerabilities.map(v => v.severity),
      ...issues.map(i => i.severity === 'critical' ? 'critical' : 
                      i.severity === 'high' ? 'high' :
                      i.severity === 'medium' ? 'medium' : 'low')
    ];

    return {
      totalVulnerabilities: allItems.length,
      criticalCount: allItems.filter(s => s === 'critical').length,
      highCount: allItems.filter(s => s === 'high').length,
      mediumCount: allItems.filter(s => s === 'medium' || s === 'moderate').length,
      lowCount: allItems.filter(s => s === 'low').length
    };
  }

  private async processScanResult(result: AutomatedScanResult): Promise<void> {
    // Send notifications if configured
    if (this.continuousMonitoring?.integrations.email) {
      await this.sendEmailNotification(result);
    }

    if (this.continuousMonitoring?.integrations.slack) {
      await this.sendSlackNotification(result);
    }

    if (this.continuousMonitoring?.integrations.webhook) {
      await this.sendWebhookNotification(result);
    }
  }

  private async runContinuousMonitoringScan(): Promise<void> {
    if (!this.continuousMonitoring?.enabled) return;

    try {
      const config: ScanConfiguration = {
        projectPath: process.cwd(),
        excludePatterns: ['node_modules/**', '**/*.test.ts'],
        includePatterns: ['**/*.ts', '**/*.js'],
        severityThreshold: 'medium',
        maxExecutionTime: 180000, // 3 minutes
        retryAttempts: 2,
        customRules: []
      };

      const scanTypes: VulnerabilityScanType[] = [
        { type: 'dependencies', enabled: true, config: {} },
        { type: 'code', enabled: true, config: {} },
        { type: 'secrets', enabled: true, config: {} }
      ];

      const result = await this.runImmediateScan(scanTypes, config);

      // Check alert thresholds
      if (result.summary.criticalCount >= this.continuousMonitoring.alertThresholds.criticalVulnerabilities) {
        await this.sendCriticalAlert(result);
      }

    } catch (error) {
      console.error('Continuous monitoring scan failed:', error);
    }
  }

  private calculateSecurityScore(scan: AutomatedScanResult | undefined): number {
    if (!scan) return 0;

    const maxScore = 100;
    const criticalPenalty = 20;
    const highPenalty = 10;
    const mediumPenalty = 5;
    const lowPenalty = 2;

    let penalty = 0;
    penalty += scan.summary.criticalCount * criticalPenalty;
    penalty += scan.summary.highCount * highPenalty;
    penalty += scan.summary.mediumCount * mediumPenalty;
    penalty += scan.summary.lowCount * lowPenalty;

    return Math.max(0, maxScore - penalty);
  }

  private getNextScheduledScanDate(): Date | null {
    let nextScan: Date | null = null;

    this.scanSchedules.forEach(schedule => {
      if (schedule.enabled && schedule.nextRun) {
        if (!nextScan || schedule.nextRun < nextScan) {
          nextScan = schedule.nextRun;
        }
      }
    });

    return nextScan;
  }

  private async sendEmailNotification(result: AutomatedScanResult): Promise<void> {
    // Email notification implementation would go here
    console.log('Email notification sent for scan:', result.scanId);
  }

  private async sendSlackNotification(result: AutomatedScanResult): Promise<void> {
    // Slack notification implementation would go here
    console.log('Slack notification sent for scan:', result.scanId);
  }

  private async sendWebhookNotification(result: AutomatedScanResult): Promise<void> {
    // Webhook notification implementation would go here
    console.log('Webhook notification sent for scan:', result.scanId);
  }

  private async sendCriticalAlert(result: AutomatedScanResult): Promise<void> {
    // Critical alert implementation would go here
    console.log('Critical security alert sent for scan:', result.scanId);
  }

  private initializeDefaultSchedules(): void {
    // Initialize default scan schedules
    const dailyDependencyScan: VulnerabilityScanSchedule = {
      id: 'daily-dependency-scan',
      name: 'Daily Dependency Scan',
      description: 'Daily scan for dependency vulnerabilities',
      frequency: 'daily',
      enabled: true,
      scanTypes: [
        { type: 'dependencies', enabled: true, config: {} }
      ],
      notificationSettings: {
        email: false,
        slack: false,
        severityThreshold: 'high',
        recipients: []
      }
    };

    const weeklyFullScan: VulnerabilityScanSchedule = {
      id: 'weekly-full-scan',
      name: 'Weekly Full Security Scan',
      description: 'Comprehensive weekly security scan',
      frequency: 'weekly',
      enabled: true,
      scanTypes: [
        { type: 'dependencies', enabled: true, config: {} },
        { type: 'code', enabled: true, config: {} },
        { type: 'configuration', enabled: true, config: {} },
        { type: 'secrets', enabled: true, config: {} }
      ],
      notificationSettings: {
        email: true,
        slack: true,
        severityThreshold: 'medium',
        recipients: ['security@company.com']
      }
    };

    this.scanSchedules.set(dailyDependencyScan.id, dailyDependencyScan);
    this.scanSchedules.set(weeklyFullScan.id, weeklyFullScan);
  }
}

export const vulnerabilityScanningAutomationService = new VulnerabilityScanningAutomationService();