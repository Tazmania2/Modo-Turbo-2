import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { 
  VulnerabilityScanningAutomationService,
  VulnerabilityScanSchedule,
  VulnerabilityScanType,
  AutomatedScanResult,
  ScanConfiguration,
  ContinuousMonitoringConfig
} from '../vulnerability-scanning-automation.service';

// Mock dependencies
jest.mock('child_process');
jest.mock('fs/promises');

describe('VulnerabilityScanningAutomationService', () => {
  let service: VulnerabilityScanningAutomationService;
  let mockScanSchedule: VulnerabilityScanSchedule;
  let mockScanConfig: ScanConfiguration;

  beforeEach(() => {
    service = new VulnerabilityScanningAutomationService();
    
    mockScanSchedule = {
      id: 'test-schedule-1',
      name: 'Test Daily Scan',
      description: 'Daily security scan for testing',
      frequency: 'daily',
      enabled: true,
      scanTypes: [
        { type: 'dependencies', enabled: true, config: {} },
        { type: 'code', enabled: true, config: {} }
      ],
      notificationSettings: {
        email: false,
        slack: false,
        severityThreshold: 'medium',
        recipients: []
      }
    };

    mockScanConfig = {
      projectPath: '/test/project',
      excludePatterns: ['node_modules/**', '**/*.test.ts'],
      includePatterns: ['**/*.ts', '**/*.js'],
      severityThreshold: 'medium',
      maxExecutionTime: 300000,
      retryAttempts: 3,
      customRules: []
    };
  });

  afterEach(() => {
    // Clean up any active scanners
    service.disableContinuousMonitoring();
  });

  describe('scheduleVulnerabilityScans', () => {
    it('should schedule vulnerability scans successfully', async () => {
      await expect(service.scheduleVulnerabilityScans(mockScanSchedule))
        .resolves.not.toThrow();
    });

    it('should not start disabled schedules', async () => {
      const disabledSchedule = { ...mockScanSchedule, enabled: false };
      
      await service.scheduleVulnerabilityScans(disabledSchedule);
      
      // Verify schedule was stored but not started
      // This would require access to internal state or additional methods
    });

    it('should handle multiple schedules', async () => {
      const schedule1 = { ...mockScanSchedule, id: 'schedule-1' };
      const schedule2 = { ...mockScanSchedule, id: 'schedule-2', frequency: 'weekly' as const };

      await service.scheduleVulnerabilityScans(schedule1);
      await service.scheduleVulnerabilityScans(schedule2);

      // Both schedules should be stored
    });
  });

  describe('runImmediateScan', () => {
    it('should run immediate scan successfully', async () => {
      const scanTypes: VulnerabilityScanType[] = [
        { type: 'dependencies', enabled: true, config: {} }
      ];

      const result = await service.runImmediateScan(scanTypes, mockScanConfig);

      expect(result).toBeDefined();
      expect(result.scanId).toBeDefined();
      expect(result.timestamp).toBeInstanceOf(Date);
      expect(result.scanType).toBe('dependencies');
      expect(result.status).toMatch(/^(completed|failed|in-progress)$/);
      expect(result.vulnerabilities).toBeInstanceOf(Array);
      expect(result.issues).toBeInstanceOf(Array);
      expect(result.summary).toBeDefined();
      expect(typeof result.executionTime).toBe('number');
      expect(result.recommendations).toBeInstanceOf(Array);
    });

    it('should handle multiple scan types', async () => {
      const scanTypes: VulnerabilityScanType[] = [
        { type: 'dependencies', enabled: true, config: {} },
        { type: 'code', enabled: true, config: {} },
        { type: 'secrets', enabled: true, config: {} }
      ];

      const result = await service.runImmediateScan(scanTypes, mockScanConfig);

      expect(result.scanType).toContain('dependencies');
      expect(result.scanType).toContain('code');
      expect(result.scanType).toContain('secrets');
    });

    it('should skip disabled scan types', async () => {
      const scanTypes: VulnerabilityScanType[] = [
        { type: 'dependencies', enabled: true, config: {} },
        { type: 'code', enabled: false, config: {} }
      ];

      const result = await service.runImmediateScan(scanTypes, mockScanConfig);

      expect(result.scanType).toBe('dependencies');
      expect(result.scanType).not.toContain('code');
    });

    it('should handle scan failures gracefully', async () => {
      const invalidConfig = { ...mockScanConfig, projectPath: '/invalid/path' };
      const scanTypes: VulnerabilityScanType[] = [
        { type: 'dependencies', enabled: true, config: {} }
      ];

      // This might throw or return a failed result depending on implementation
      try {
        const result = await service.runImmediateScan(scanTypes, invalidConfig);
        expect(result.status).toBe('failed');
      } catch (error) {
        expect(error).toBeDefined();
      }
    });

    it('should generate proper scan summary', async () => {
      const scanTypes: VulnerabilityScanType[] = [
        { type: 'dependencies', enabled: true, config: {} }
      ];

      const result = await service.runImmediateScan(scanTypes, mockScanConfig);

      expect(result.summary).toBeDefined();
      expect(typeof result.summary.totalVulnerabilities).toBe('number');
      expect(typeof result.summary.criticalCount).toBe('number');
      expect(typeof result.summary.highCount).toBe('number');
      expect(typeof result.summary.mediumCount).toBe('number');
      expect(typeof result.summary.lowCount).toBe('number');
    });
  });

  describe('enableContinuousMonitoring', () => {
    it('should enable continuous monitoring', async () => {
      const config: ContinuousMonitoringConfig = {
        enabled: true,
        scanInterval: 60, // 1 hour
        alertThresholds: {
          newVulnerabilities: 5,
          criticalVulnerabilities: 1,
          securityScoreDecrease: 10
        },
        integrations: {
          github: false,
          slack: false,
          email: false
        }
      };

      await expect(service.enableContinuousMonitoring(config))
        .resolves.not.toThrow();
    });

    it('should not start monitoring when disabled', async () => {
      const config: ContinuousMonitoringConfig = {
        enabled: false,
        scanInterval: 60,
        alertThresholds: {
          newVulnerabilities: 5,
          criticalVulnerabilities: 1,
          securityScoreDecrease: 10
        },
        integrations: {
          github: false,
          slack: false,
          email: false
        }
      };

      await service.enableContinuousMonitoring(config);
      
      // Monitoring should not be active
    });
  });

  describe('disableContinuousMonitoring', () => {
    it('should disable continuous monitoring', async () => {
      const config: ContinuousMonitoringConfig = {
        enabled: true,
        scanInterval: 1, // 1 minute for testing
        alertThresholds: {
          newVulnerabilities: 5,
          criticalVulnerabilities: 1,
          securityScoreDecrease: 10
        },
        integrations: {
          github: false,
          slack: false,
          email: false
        }
      };

      await service.enableContinuousMonitoring(config);
      service.disableContinuousMonitoring();

      // Monitoring should be stopped
    });
  });

  describe('getScanHistory', () => {
    it('should return scan history', async () => {
      // First run a scan to create history
      const scanTypes: VulnerabilityScanType[] = [
        { type: 'dependencies', enabled: true, config: {} }
      ];

      await service.runImmediateScan(scanTypes, mockScanConfig);

      const history = service.getScanHistory();

      expect(history).toBeInstanceOf(Array);
      expect(history.length).toBeGreaterThan(0);
    });

    it('should limit scan history when requested', async () => {
      // Run multiple scans
      const scanTypes: VulnerabilityScanType[] = [
        { type: 'dependencies', enabled: true, config: {} }
      ];

      await service.runImmediateScan(scanTypes, mockScanConfig);
      await service.runImmediateScan(scanTypes, mockScanConfig);
      await service.runImmediateScan(scanTypes, mockScanConfig);

      const limitedHistory = service.getScanHistory(2);

      expect(limitedHistory).toBeInstanceOf(Array);
      expect(limitedHistory.length).toBeLessThanOrEqual(2);
    });

    it('should return history in chronological order (newest first)', async () => {
      const scanTypes: VulnerabilityScanType[] = [
        { type: 'dependencies', enabled: true, config: {} }
      ];

      const firstScan = await service.runImmediateScan(scanTypes, mockScanConfig);
      
      // Wait a bit to ensure different timestamps
      await new Promise(resolve => setTimeout(resolve, 10));
      
      const secondScan = await service.runImmediateScan(scanTypes, mockScanConfig);

      const history = service.getScanHistory();

      expect(history.length).toBeGreaterThanOrEqual(2);
      expect(history[0].timestamp.getTime()).toBeGreaterThanOrEqual(history[1].timestamp.getTime());
    });
  });

  describe('getVulnerabilityTrends', () => {
    it('should return vulnerability trends', async () => {
      // Run a scan to create data
      const scanTypes: VulnerabilityScanType[] = [
        { type: 'dependencies', enabled: true, config: {} }
      ];

      await service.runImmediateScan(scanTypes, mockScanConfig);

      const trends = service.getVulnerabilityTrends(7);

      expect(trends).toBeInstanceOf(Array);
      trends.forEach(trend => {
        expect(trend.date).toBeDefined();
        expect(typeof trend.totalVulnerabilities).toBe('number');
        expect(typeof trend.criticalCount).toBe('number');
        expect(typeof trend.highCount).toBe('number');
        expect(typeof trend.mediumCount).toBe('number');
        expect(typeof trend.lowCount).toBe('number');
      });
    });

    it('should filter trends by date range', async () => {
      const trends30Days = service.getVulnerabilityTrends(30);
      const trends7Days = service.getVulnerabilityTrends(7);

      // 30-day trends should include more or equal data points than 7-day
      expect(trends30Days.length).toBeGreaterThanOrEqual(trends7Days.length);
    });

    it('should return empty array when no scan history exists', () => {
      const trends = service.getVulnerabilityTrends(30);

      expect(trends).toBeInstanceOf(Array);
      expect(trends.length).toBe(0);
    });
  });

  describe('getSecurityDashboardMetrics', () => {
    it('should return security dashboard metrics', async () => {
      // Run a scan to create data
      const scanTypes: VulnerabilityScanType[] = [
        { type: 'dependencies', enabled: true, config: {} }
      ];

      await service.runImmediateScan(scanTypes, mockScanConfig);

      const metrics = service.getSecurityDashboardMetrics();

      expect(metrics).toBeDefined();
      expect(typeof metrics.currentSecurityScore).toBe('number');
      expect(typeof metrics.totalVulnerabilities).toBe('number');
      expect(typeof metrics.criticalVulnerabilities).toBe('number');
      expect(metrics.trendsLast30Days).toBeInstanceOf(Array);
      expect(metrics.topVulnerabilityTypes).toBeInstanceOf(Array);
      expect(metrics.scanFrequency).toBeDefined();
      expect(typeof metrics.scanFrequency.successful).toBe('number');
      expect(typeof metrics.scanFrequency.failed).toBe('number');
      expect(typeof metrics.scanFrequency.total).toBe('number');
    });

    it('should handle empty scan history', () => {
      const metrics = service.getSecurityDashboardMetrics();

      expect(metrics.currentSecurityScore).toBe(0);
      expect(metrics.totalVulnerabilities).toBe(0);
      expect(metrics.criticalVulnerabilities).toBe(0);
      expect(metrics.lastScanDate).toBeNull();
    });
  });

  describe('Scan Type Implementations', () => {
    describe('Dependencies Scan', () => {
      it('should scan dependencies successfully', async () => {
        const scanTypes: VulnerabilityScanType[] = [
          { type: 'dependencies', enabled: true, config: {} }
        ];

        const result = await service.runImmediateScan(scanTypes, mockScanConfig);

        expect(result.status).toBe('completed');
        expect(result.vulnerabilities).toBeInstanceOf(Array);
      });
    });

    describe('Code Scan', () => {
      it('should scan code successfully', async () => {
        const scanTypes: VulnerabilityScanType[] = [
          { type: 'code', enabled: true, config: {} }
        ];

        const result = await service.runImmediateScan(scanTypes, mockScanConfig);

        expect(result.status).toBe('completed');
        expect(result.issues).toBeInstanceOf(Array);
      });
    });

    describe('Configuration Scan', () => {
      it('should scan configuration successfully', async () => {
        const scanTypes: VulnerabilityScanType[] = [
          { type: 'configuration', enabled: true, config: {} }
        ];

        const result = await service.runImmediateScan(scanTypes, mockScanConfig);

        expect(result.status).toBe('completed');
        expect(result.issues).toBeInstanceOf(Array);
      });
    });

    describe('Secrets Scan', () => {
      it('should scan for secrets successfully', async () => {
        const scanTypes: VulnerabilityScanType[] = [
          { type: 'secrets', enabled: true, config: {} }
        ];

        const result = await service.runImmediateScan(scanTypes, mockScanConfig);

        expect(result.status).toBe('completed');
        expect(result.issues).toBeInstanceOf(Array);
      });
    });

    describe('Infrastructure Scan', () => {
      it('should scan infrastructure successfully', async () => {
        const scanTypes: VulnerabilityScanType[] = [
          { type: 'infrastructure', enabled: true, config: {} }
        ];

        const result = await service.runImmediateScan(scanTypes, mockScanConfig);

        expect(result.status).toBe('completed');
        expect(result.issues).toBeInstanceOf(Array);
      });
    });
  });

  describe('Error Handling', () => {
    it('should handle invalid scan configuration', async () => {
      const invalidConfig = { ...mockScanConfig, projectPath: '' };
      const scanTypes: VulnerabilityScanType[] = [
        { type: 'dependencies', enabled: true, config: {} }
      ];

      try {
        const result = await service.runImmediateScan(scanTypes, invalidConfig);
        expect(result.status).toBe('failed');
      } catch (error) {
        expect(error).toBeDefined();
      }
    });

    it('should handle scan timeout', async () => {
      const timeoutConfig = { ...mockScanConfig, maxExecutionTime: 1 }; // 1ms timeout
      const scanTypes: VulnerabilityScanType[] = [
        { type: 'dependencies', enabled: true, config: {} }
      ];

      try {
        const result = await service.runImmediateScan(scanTypes, timeoutConfig);
        // Should either complete quickly or fail gracefully
        expect(result).toBeDefined();
      } catch (error) {
        expect(error).toBeDefined();
      }
    });

    it('should handle network errors gracefully', async () => {
      // This would require mocking network calls to fail
      const scanTypes: VulnerabilityScanType[] = [
        { type: 'dependencies', enabled: true, config: {} }
      ];

      const result = await service.runImmediateScan(scanTypes, mockScanConfig);

      expect(result).toBeDefined();
      // Should handle network errors gracefully
    });
  });

  describe('Performance', () => {
    it('should complete scans within reasonable time', async () => {
      const scanTypes: VulnerabilityScanType[] = [
        { type: 'dependencies', enabled: true, config: {} }
      ];

      const startTime = Date.now();
      const result = await service.runImmediateScan(scanTypes, mockScanConfig);
      const executionTime = Date.now() - startTime;

      expect(executionTime).toBeLessThan(10000); // 10 seconds max
      expect(result.executionTime).toBeGreaterThan(0);
    });

    it('should handle concurrent scans', async () => {
      const scanTypes: VulnerabilityScanType[] = [
        { type: 'dependencies', enabled: true, config: {} }
      ];

      const promises = Array(3).fill(null).map(() => 
        service.runImmediateScan(scanTypes, mockScanConfig)
      );

      const results = await Promise.all(promises);

      expect(results).toHaveLength(3);
      results.forEach(result => {
        expect(result.status).toBe('completed');
      });
    });
  });

  describe('Notifications', () => {
    it('should handle notification settings', async () => {
      const scheduleWithNotifications: VulnerabilityScanSchedule = {
        ...mockScanSchedule,
        notificationSettings: {
          email: true,
          slack: true,
          severityThreshold: 'high',
          recipients: ['test@example.com']
        }
      };

      await expect(service.scheduleVulnerabilityScans(scheduleWithNotifications))
        .resolves.not.toThrow();
    });
  });

  describe('Custom Rules', () => {
    it('should apply custom security rules', async () => {
      const configWithCustomRules: ScanConfiguration = {
        ...mockScanConfig,
        customRules: [
          {
            id: 'custom-rule-1',
            name: 'Test Custom Rule',
            description: 'A test custom security rule',
            pattern: /test-pattern/gi,
            severity: 'medium',
            category: 'custom',
            enabled: true,
            remediation: 'Fix the test pattern'
          }
        ]
      };

      const scanTypes: VulnerabilityScanType[] = [
        { type: 'code', enabled: true, config: {} }
      ];

      const result = await service.runImmediateScan(scanTypes, configWithCustomRules);

      expect(result).toBeDefined();
      // Custom rules should be applied during code scanning
    });
  });
});